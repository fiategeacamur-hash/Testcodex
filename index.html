<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Geometry Dash Clone</title>
  <style>
    :root {
      --bg-top: #141432;
      --bg-bottom: #1f6acb;
      --accent: #ffe066;
      --panel: rgba(10, 12, 34, 0.8);
      --text: #f7f7ff;
      --muted: #b7c0e0;
      --button: #3bb273;
      --button-hover: #4fd48d;
      --danger: #ff6b6b;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: linear-gradient(180deg, var(--bg-top), var(--bg-bottom));
      color: var(--text);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    #game-container {
      position: relative;
      width: min(100vw, 1100px);
      aspect-ratio: 16 / 9;
      max-height: 95vh;
      border-radius: 18px;
      overflow: hidden;
      box-shadow: var(--shadow);
      border: 2px solid rgba(255, 255, 255, 0.1);
      background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.04), transparent 40%),
                  radial-gradient(circle at 80% 0%, rgba(255, 255, 255, 0.05), transparent 35%),
                  linear-gradient(180deg, rgba(255, 255, 255, 0.04), transparent 50%);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle at center, rgba(20, 20, 50, 0.85), rgba(5, 8, 20, 0.95));
      backdrop-filter: blur(6px);
      z-index: 5;
      padding: 20px;
      flex-direction: column;
      gap: 18px;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-size: clamp(28px, 5vw, 48px);
      letter-spacing: 2px;
    }

    p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
      max-width: 640px;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px;
    }

    button {
      background: var(--button);
      border: none;
      color: #0b1c2c;
      font-weight: 700;
      padding: 12px 18px;
      border-radius: 12px;
      cursor: pointer;
      min-width: 140px;
      box-shadow: var(--shadow);
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
      font-size: 15px;
    }

    button:hover {
      background: var(--button-hover);
      transform: translateY(-2px);
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.35);
    }

    button.danger {
      background: var(--danger);
      color: #fff;
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.12);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: none;
    }

    button.small {
      min-width: 100px;
      padding: 8px 12px;
      font-size: 13px;
    }

    #character-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 14px;
      width: 100%;
      max-width: 640px;
    }

    .character-card {
      border-radius: 12px;
      padding: 12px;
      border: 2px solid transparent;
      background: rgba(255, 255, 255, 0.05);
      position: relative;
      cursor: pointer;
      transition: border-color 150ms ease, transform 150ms ease;
      box-shadow: var(--shadow);
    }

    .character-card:hover {
      transform: translateY(-3px);
    }

    .character-card.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(255, 224, 102, 0.3), var(--shadow);
    }

    .character-preview {
      width: 72px;
      height: 72px;
      margin: 0 auto 10px;
      border-radius: 10px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .info-text {
      font-size: 14px;
      color: var(--muted);
    }

    #hud {
      position: absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      font-weight: 700;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
      z-index: 2;
      pointer-events: none;
    }

    #pause-btn {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3;
      pointer-events: auto;
    }

    #progress-bar {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      height: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      overflow: hidden;
    }

    #progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #5efce8, #736efe);
    }

    @media (max-width: 640px) {
      #game-container {
        border-radius: 0;
        max-height: 100vh;
      }
      button {
        min-width: 120px;
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="game" aria-label="Geometry Dash Clone"></canvas>
    <div id="hud">
      <div id="attempt">Attempt: 1</div>
      <div id="distance">0%</div>
    </div>
    <button id="pause-btn" class="small secondary" aria-label="Pause">Pause</button>
    <div id="progress-bar"><div id="progress-fill"></div></div>

    <div id="menu" class="overlay">
      <h1>Geometry Dash Clone</h1>
      <p>Jump over spikes and gaps to survive! Tap or press Space to jump. Hold to chain jumps.</p>
      <div class="btn-row">
        <button id="play-btn">Play</button>
        <button id="character-btn" class="secondary">Character Select</button>
      </div>
      <div class="btn-row">
        <button id="instructions-btn" class="secondary">How to Play</button>
        <button id="mute-btn" class="secondary">ðŸ”Š Sound</button>
      </div>
    </div>

    <div id="character-select" class="overlay" style="display:none;">
      <h1>Select Your Character</h1>
      <p class="info-text">All characters handle the same. Pick a style you like!</p>
      <div id="character-grid"></div>
      <div class="btn-row">
        <button id="character-confirm">Save &amp; Back</button>
        <button id="character-back" class="secondary">Back to Menu</button>
      </div>
    </div>

    <div id="instructions" class="overlay" style="display:none;">
      <h1>How to Play</h1>
      <p>Press Space or click / tap to jump. Hold to keep jumping over consecutive obstacles. Avoid spikes, blocks, and falling into gaps. Reach the end of the level to win!</p>
      <div class="btn-row">
        <button id="instructions-back">Back</button>
      </div>
    </div>

    <div id="pause-menu" class="overlay" style="display:none;">
      <h1>Paused</h1>
      <div class="btn-row">
        <button id="resume-btn">Resume</button>
        <button id="restart-btn" class="secondary">Restart Level</button>
        <button id="pause-main-btn" class="danger">Main Menu</button>
      </div>
    </div>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');

    function resizeCanvas() {
      const rect = container.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      // Reset transform before re-scaling to avoid compounding scale on resize
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Game states
    const STATE_MENU = 'menu';
    const STATE_CHARACTER = 'character';
    const STATE_INSTRUCTIONS = 'instructions';
    const STATE_PLAYING = 'playing';
    const STATE_PAUSED = 'paused';

    let currentState = STATE_MENU;

    // UI elements
    const menu = document.getElementById('menu');
    const characterScreen = document.getElementById('character-select');
    const instructionsScreen = document.getElementById('instructions');
    const pauseMenu = document.getElementById('pause-menu');
    const attemptLabel = document.getElementById('attempt');
    const distanceLabel = document.getElementById('distance');
    const progressFill = document.getElementById('progress-fill');
    const pauseBtn = document.getElementById('pause-btn');

    // Character options (purely cosmetic)
    const characters = [
      { id: 'sunset', color: '#ff7f50', eye: '#0b1c2c', border: '#ffd1a4', trail: '#ff9f68' },
      { id: 'aqua', color: '#5efce8', eye: '#0d2030', border: '#bdfcf2', trail: '#40c9ff' },
      { id: 'lime', color: '#7bed9f', eye: '#0b1c2c', border: '#d4ffd4', trail: '#2ed573' },
      { id: 'violet', color: '#a48bff', eye: '#0b1c2c', border: '#e6dcff', trail: '#736efe' }
    ];

    let selectedCharacter = localStorage.getItem('gd-character') || characters[0].id;

    // Sound manager using Web Audio API
    class SoundManager {
      constructor() {
        this.audioCtx = null;
        this.muted = localStorage.getItem('gd-muted') === 'true';
        this.musicOsc = null;
        this.musicGain = null;
        this.musicTimer = null;
        this.musicLoopDuration = 3.2; // seconds
      }

      ensureContext() {
        if (!this.audioCtx) {
          this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.audioCtx.state === 'suspended') {
          this.audioCtx.resume();
        }
      }

      playTone(frequency, duration, type = 'square', volume = 0.2) {
        if (this.muted) return;
        this.ensureContext();
        const osc = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = frequency;
        gain.gain.value = volume;
        osc.connect(gain).connect(this.audioCtx.destination);
        osc.start();
        osc.stop(this.audioCtx.currentTime + duration);
      }

      playJump() {
        this.playTone(620, 0.08, 'square', 0.25);
      }

      playDeath() {
        this.playTone(120, 0.25, 'sawtooth', 0.2);
      }

      startMusic() {
        if (this.muted) return;
        this.ensureContext();
        this.stopMusic();
        this.musicGain = this.audioCtx.createGain();
        this.musicGain.gain.value = 0.1;
        this.musicGain.connect(this.audioCtx.destination);

        // Simple looping melody with two oscillators that are stopped before re-starting
        const now = this.audioCtx.currentTime;
        const end = now + this.musicLoopDuration;

        const osc1 = this.audioCtx.createOscillator();
        osc1.type = 'triangle';
        osc1.frequency.setValueAtTime(180, now);
        osc1.frequency.linearRampToValueAtTime(200, now + 1.6);
        osc1.frequency.linearRampToValueAtTime(180, end);

        const osc2 = this.audioCtx.createOscillator();
        osc2.type = 'square';
        osc2.frequency.value = 90;

        osc1.connect(this.musicGain);
        osc2.connect(this.musicGain);
        osc1.start(now);
        osc2.start(now);
        osc1.stop(end);
        osc2.stop(end);

        this.musicOsc = [osc1, osc2];

        // Recreate the melody after it ends to prevent stuck tones from piling up
        this.musicTimer = setTimeout(() => {
          this.startMusic();
        }, this.musicLoopDuration * 1000);
      }

      stopMusic() {
        if (this.musicTimer) {
          clearTimeout(this.musicTimer);
          this.musicTimer = null;
        }
        if (this.musicOsc) {
          this.musicOsc.forEach(o => {
            try { o.stop(); } catch (e) {}
          });
          this.musicOsc = null;
        }
      }

      toggleMute() {
        this.muted = !this.muted;
        localStorage.setItem('gd-muted', this.muted);
        if (this.muted) {
          this.stopMusic();
        } else {
          this.startMusic();
        }
        updateMuteButton();
      }
    }

    const sounds = new SoundManager();

    // Player and level data
    const groundHeight = 90; // px from bottom
    const gravity = 1500;
    const jumpVelocity = -600;
    const speed = 240;

    const player = {
      x: 120,
      y: 0,
      width: 40,
      height: 40,
      vy: 0,
      grounded: false,
      trail: []
    };

    let cameraX = 0;
    let attempt = 1;
    let jumpHeld = false;
    let levelLength = 3200;

    // Define level obstacles
    const obstacles = [];
    function addSpike(x, width = 40, height = 60) {
      obstacles.push({ type: 'spike', x, width, height });
    }
    function addBlock(x, width, height) {
      obstacles.push({ type: 'block', x, width, height });
    }
    function addGap(x, width) {
      obstacles.push({ type: 'gap', x, width });
    }

    function buildLevel() {
      obstacles.length = 0;
      let x = 300;
      addSpike(x); x += 160;
      addSpike(x); x += 120;
      addBlock(x, 80, 40); x += 200;
      addGap(x, 140); x += 260;
      addSpike(x); x += 100;
      addBlock(x, 100, 60); x += 160;
      addSpike(x); x += 80;
      addSpike(x + 50); x += 230;
      addGap(x, 200); x += 320;
      addBlock(x, 120, 40); x += 180;
      addSpike(x, 50, 70); x += 140;
      addSpike(x + 40); x += 260;
      addGap(x, 220); x += 320;
      addBlock(x, 140, 60); x += 220;
      addSpike(x); x += 120;
      levelLength = x + 400;
    }

    buildLevel();

    function resetPlayer() {
      player.x = 120;
      player.y = canvas.height / (window.devicePixelRatio || 1) - groundHeight - player.height;
      player.vy = 0;
      player.grounded = false;
      player.trail = [];
      cameraX = 0;
    }

    resetPlayer();

    // Input handling
    function setJump(state) {
      jumpHeld = state;
      if (state && player.grounded && currentState === STATE_PLAYING) {
        jump();
      }
    }

    function jump() {
      player.vy = jumpVelocity;
      player.grounded = false;
      sounds.playJump();
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        setJump(true);
      }
      if (e.code === 'Escape' && currentState === STATE_PLAYING) {
        pauseGame();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        setJump(false);
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      setJump(true);
    });
    canvas.addEventListener('mouseup', () => setJump(false));
    canvas.addEventListener('mouseleave', () => setJump(false));

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      setJump(true);
    }, { passive: false });
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      setJump(false);
    }, { passive: false });

    // Button wiring
    document.getElementById('play-btn').addEventListener('click', () => startGame());
    document.getElementById('character-btn').addEventListener('click', () => showCharacterSelect());
    document.getElementById('instructions-btn').addEventListener('click', () => showInstructions());
    document.getElementById('instructions-back').addEventListener('click', () => goToMenu());
    document.getElementById('character-back').addEventListener('click', () => goToMenu());
    document.getElementById('character-confirm').addEventListener('click', () => {
      localStorage.setItem('gd-character', selectedCharacter);
      goToMenu();
    });
    document.getElementById('mute-btn').addEventListener('click', () => sounds.toggleMute());
    pauseBtn.addEventListener('click', () => {
      if (currentState === STATE_PLAYING) pauseGame();
    });
    document.getElementById('resume-btn').addEventListener('click', () => resumeGame());
    document.getElementById('restart-btn').addEventListener('click', () => restartLevel());
    document.getElementById('pause-main-btn').addEventListener('click', () => goToMenu());

    function updateMuteButton() {
      const btn = document.getElementById('mute-btn');
      btn.textContent = sounds.muted ? 'ðŸ”‡ Muted' : 'ðŸ”Š Sound';
    }
    updateMuteButton();

    // Character select rendering
    const grid = document.getElementById('character-grid');
    function drawCharacterCard(char) {
      const card = document.createElement('div');
      card.className = 'character-card';
      card.dataset.id = char.id;

      const preview = document.createElement('div');
      preview.className = 'character-preview';
      preview.style.background = char.color;
      preview.style.border = `4px solid ${char.border}`;

      // Simple face
      const eye = document.createElement('div');
      eye.style.width = '14px';
      eye.style.height = '14px';
      eye.style.borderRadius = '50%';
      eye.style.background = char.eye;
      eye.style.boxShadow = '18px 0 0 ' + char.eye;

      preview.appendChild(eye);

      const trail = document.createElement('div');
      trail.style.position = 'absolute';
      trail.style.left = '-30%';
      trail.style.right = '60%';
      trail.style.top = '35%';
      trail.style.bottom = '35%';
      trail.style.background = char.trail;
      trail.style.filter = 'blur(8px)';
      preview.appendChild(trail);

      const label = document.createElement('div');
      label.textContent = char.id.toUpperCase();
      label.style.fontSize = '13px';
      label.style.letterSpacing = '1px';
      label.style.color = 'var(--text)';

      card.appendChild(preview);
      card.appendChild(label);

      card.addEventListener('click', () => {
        selectedCharacter = char.id;
        highlightSelection();
      });

      return card;
    }

    function highlightSelection() {
      document.querySelectorAll('.character-card').forEach(card => {
        card.classList.toggle('selected', card.dataset.id === selectedCharacter);
      });
    }

    function populateCharacters() {
      grid.innerHTML = '';
      characters.forEach(char => grid.appendChild(drawCharacterCard(char)));
      highlightSelection();
    }

    populateCharacters();

    // State helpers
    function goToMenu() {
      currentState = STATE_MENU;
      menu.style.display = 'flex';
      characterScreen.style.display = 'none';
      instructionsScreen.style.display = 'none';
      pauseMenu.style.display = 'none';
      pauseBtn.style.display = 'none';
      sounds.startMusic();
    }

    function showCharacterSelect() {
      currentState = STATE_CHARACTER;
      menu.style.display = 'none';
      characterScreen.style.display = 'flex';
      instructionsScreen.style.display = 'none';
      pauseMenu.style.display = 'none';
      pauseBtn.style.display = 'none';
    }

    function showInstructions() {
      currentState = STATE_INSTRUCTIONS;
      menu.style.display = 'none';
      instructionsScreen.style.display = 'flex';
      characterScreen.style.display = 'none';
      pauseMenu.style.display = 'none';
      pauseBtn.style.display = 'none';
    }

    function startGame() {
      attempt = 1;
      attemptLabel.textContent = `Attempt: ${attempt}`;
      resetPlayer();
      currentState = STATE_PLAYING;
      menu.style.display = 'none';
      characterScreen.style.display = 'none';
      instructionsScreen.style.display = 'none';
      pauseMenu.style.display = 'none';
      pauseBtn.style.display = 'block';
      sounds.startMusic();
    }

    function restartLevel() {
      attempt++;
      attemptLabel.textContent = `Attempt: ${attempt}`;
      resetPlayer();
      resumeGame();
    }

    function pauseGame() {
      currentState = STATE_PAUSED;
      pauseMenu.style.display = 'flex';
    }

    function resumeGame() {
      currentState = STATE_PLAYING;
      pauseMenu.style.display = 'none';
    }

    // Physics helpers
    function isOverGap(xPos) {
      return obstacles.some(o => o.type === 'gap' && xPos + player.width > o.x && xPos < o.x + o.width);
    }

    function rectIntersect(a, b) {
      return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
    }

    function spikeIntersect(rect, spike) {
      // Triangle points
      const ax = spike.x;
      const ay = groundY();
      const bx = spike.x + spike.width / 2;
      const by = groundY() - spike.height;
      const cx = spike.x + spike.width;
      const cy = groundY();

      // Check all four corners of the player within triangle using barycentric technique
      const points = [
        { x: rect.x, y: rect.y },
        { x: rect.x + rect.width, y: rect.y },
        { x: rect.x, y: rect.y + rect.height },
        { x: rect.x + rect.width, y: rect.y + rect.height }
      ];

      const area = Math.abs((ax*(by-cy) + bx*(cy-ay) + cx*(ay-by)) / 2);
      for (const p of points) {
        const area1 = Math.abs((p.x*(by-cy) + bx*(cy-p.y) + cx*(p.y-by)) / 2);
        const area2 = Math.abs((ax*(p.y-cy) + p.x*(cy-ay) + cx*(ay-p.y)) / 2);
        const area3 = Math.abs((ax*(by-p.y) + bx*(p.y-ay) + p.x*(ay-by)) / 2);
        if (Math.abs(area - (area1 + area2 + area3)) < 0.5) return true;
      }
      return false;
    }

    function groundY() {
      return canvas.getBoundingClientRect().height - groundHeight;
    }

    function collisionCheck() {
      const rect = { x: player.x, y: player.y, width: player.width, height: player.height };

      // Ground collision only if not above a gap
      if (!isOverGap(player.x + player.width / 2)) {
        const ground = groundY() - player.height;
        if (player.y >= ground) {
          player.y = ground;
          player.vy = 0;
          player.grounded = true;
        }
      }

      for (const o of obstacles) {
        if (o.type === 'block') {
          const blockRect = { x: o.x, y: groundY() - o.height, width: o.width, height: o.height };
          if (rectIntersect(rect, blockRect)) {
            // Basic collision response: place player on top if falling
            if (player.vy >= 0 && rect.y + rect.height - player.vy * dt <= blockRect.y) {
              player.y = blockRect.y - player.height;
              player.vy = 0;
              player.grounded = true;
            } else {
              return true;
            }
          }
        } else if (o.type === 'spike') {
          if (rectIntersect(rect, { x: o.x, y: groundY() - o.height, width: o.width, height: o.height }) && spikeIntersect(rect, o)) {
            return true;
          }
        }
      }
      return false;
    }

    function reachedGoal() {
      return player.x >= levelLength;
    }

    // Game loop
    let lastTime = 0;
    let dt = 0;
    function loop(timestamp) {
      dt = (timestamp - lastTime) / 1000 || 0;
      lastTime = timestamp;

      if (currentState === STATE_PLAYING) {
        update(dt);
        render();
      } else {
        render();
      }

      requestAnimationFrame(loop);
    }

    function update(dt) {
      // Horizontal motion
      player.x += speed * dt;

      // Vertical motion
      player.vy += gravity * dt;
      player.y += player.vy * dt;

      // Automatic jump if holding input and grounded
      if (jumpHeld && player.grounded) {
        jump();
      }

      // Prevent falling through floor when over solid ground
      if (!isOverGap(player.x + player.width / 2)) {
        const ground = groundY() - player.height;
        if (player.y > ground) {
          player.y = ground;
          player.vy = 0;
          player.grounded = true;
        }
      } else {
        player.grounded = false;
      }

      // Collisions with obstacles
      const dead = collisionCheck();
      if (dead || player.y > canvas.getBoundingClientRect().height) {
        sounds.playDeath();
        restartLevel();
        return;
      }

      // Goal reached
      if (reachedGoal()) {
        // Simple victory: loop the level with a new attempt count reset
        attempt = 1;
        levelCompleteFlash = 1;
        resetPlayer();
      }

      // Camera follows player
      cameraX = player.x - 150;

      // HUD updates
      const progress = Math.min(player.x / levelLength, 1);
      distanceLabel.textContent = `${Math.floor(progress * 100)}%`;
      progressFill.style.width = `${Math.floor(progress * 100)}%`;

      // Particle trail
      const char = characters.find(c => c.id === selectedCharacter) || characters[0];
      player.trail.unshift({ x: player.x, y: player.y + player.height / 2, life: 0.5, color: char.trail });
      if (player.trail.length > 40) player.trail.pop();
    }

    let levelCompleteFlash = 0;

    function renderBackground() {
      const { width, height } = canvas.getBoundingClientRect();
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, '#0f1025');
      grad.addColorStop(1, '#16284b');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, width, height);

      // Moving parallax dots
      ctx.fillStyle = 'rgba(255,255,255,0.1)';
      for (let i = 0; i < 80; i++) {
        const px = (i * 80 + cameraX * 0.2) % (width + 80) - 40;
        const py = (i * 37) % height;
        ctx.beginPath();
        ctx.arc(px, py, 2 + (i % 3) * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawGround() {
      const { width } = canvas.getBoundingClientRect();
      const y = groundY();
      ctx.fillStyle = '#0d1a2c';
      ctx.fillRect(0, y, width, groundHeight);
      ctx.fillStyle = '#243b55';
      ctx.fillRect(0, y, width, 6);
      // Grid lines
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      for (let gx = -((cameraX % 40)); gx < width; gx += 40) {
        ctx.beginPath();
        ctx.moveTo(gx, y);
        ctx.lineTo(gx + 10, y + groundHeight);
        ctx.stroke();
      }
    }

    function drawObstacles() {
      const { width } = canvas.getBoundingClientRect();
      const char = characters.find(c => c.id === selectedCharacter) || characters[0];
      const viewStart = cameraX - 80;
      const viewEnd = cameraX + width + 80;

      obstacles.forEach(o => {
        if (o.x + o.width < viewStart || o.x > viewEnd) return;
        if (o.type === 'block') {
          ctx.fillStyle = '#ff6b6b';
          ctx.strokeStyle = '#ffc6c6';
          const x = o.x - cameraX;
          const y = groundY() - o.height;
          ctx.fillRect(x, y, o.width, o.height);
          ctx.strokeRect(x, y, o.width, o.height);
        } else if (o.type === 'spike') {
          const x = o.x - cameraX;
          const baseY = groundY();
          ctx.fillStyle = '#ffa94d';
          ctx.strokeStyle = '#ffd8a8';
          ctx.beginPath();
          ctx.moveTo(x, baseY);
          ctx.lineTo(x + o.width / 2, baseY - o.height);
          ctx.lineTo(x + o.width, baseY);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }
      });

      // Simple finish line
      ctx.fillStyle = char.trail;
      const finishX = levelLength - cameraX;
      ctx.fillRect(finishX, groundY() - 120, 12, 120);
    }

    function drawPlayer() {
      const { width } = canvas.getBoundingClientRect();
      const char = characters.find(c => c.id === selectedCharacter) || characters[0];

      // Draw trail particles
      player.trail.forEach(p => {
        const x = p.x - cameraX;
        const y = p.y;
        ctx.fillStyle = `rgba(${hexToRgb(p.color)}, ${Math.max(0, p.life)})`;
        ctx.beginPath();
        ctx.arc(x, y, 8 * p.life, 0, Math.PI * 2);
        ctx.fill();
        p.life -= dt * 2;
      });

      const x = player.x - cameraX;
      const y = player.y;
      ctx.fillStyle = char.color;
      ctx.strokeStyle = char.border;
      ctx.lineWidth = 4;
      ctx.fillRect(x, y, player.width, player.height);
      ctx.strokeRect(x, y, player.width, player.height);

      // Face
      ctx.fillStyle = char.eye;
      ctx.beginPath();
      ctx.arc(x + 12, y + 16, 6, 0, Math.PI * 2);
      ctx.arc(x + 28, y + 16, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#0b1c2c';
      ctx.fillRect(x + 10, y + 26, 20, 6);
    }

    function hexToRgb(hex) {
      const value = hex.replace('#', '');
      const bigint = parseInt(value, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `${r}, ${g}, ${b}`;
    }

    function render() {
      renderBackground();
      drawObstacles();
      drawGround();
      drawPlayer();

      if (levelCompleteFlash > 0) {
        const { width, height } = canvas.getBoundingClientRect();
        ctx.fillStyle = `rgba(255, 255, 255, ${levelCompleteFlash})`;
        ctx.fillRect(0, 0, width, height);
        levelCompleteFlash -= dt;
      }
    }

    // Start loop
    requestAnimationFrame(loop);

    // Begin at menu and music
    goToMenu();
  </script>
</body>
</html>
